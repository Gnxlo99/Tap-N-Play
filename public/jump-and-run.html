<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Jump & Run</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;800&display=swap" rel="stylesheet">
    
    <!-- Google Analytics - Replace G-XXXXXXXXXX with your ID -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-XXXXXXXXXX');
    </script>

    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222831;
            font-family: 'Poppins', sans-serif;
            color: #EEEEEE;
            overflow: hidden;
            overscroll-behavior-y: contain;
            -webkit-tap-highlight-color: transparent;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 360px; /* Corresponds to CANVAS_WIDTH */
            aspect-ratio: 9 / 16;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 10;
            color: #EEEEEE;
        }
        .modal-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            padding: 40px 0;
            box-sizing: border-box;
        }
        .modal-content h1 {
            font-size: 48px;
            font-weight: 800;
            margin: 0;
        }
        #scores {
            font-size: 24px;
            margin-bottom: 0;
        }
        #scores p {
            margin: 5px 0;
            font-weight: 600;
        }
        #game-over-message {
            font-size: 22px;
            font-style: italic;
            color: #AAAAAA;
            margin: 0 20px;
            min-height: 60px; /* Prevents layout shift */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #retry-button {
            font-family: 'Poppins', sans-serif;
            font-size: 24px;
            font-weight: 600;
            color: #222831;
            background-color: #EEEEEE;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s ease, opacity 0.3s ease;
        }
        #retry-button:active {
            transform: scale(0.95);
        }
        #retry-button.disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="game-over-screen" style="display: none;">
            <div class="modal-content">
                <h1>Game Over</h1>
                <div id="scores">
                    <p>Score: <span id="current-score">0</span></p>
                    <p>High Score: <span id="high-score">0</span></p>
                </div>
                <p id="game-over-message"></p>
                <button id="retry-button">Retry</button>
            </div>
        </div>
    </div>

    <script>
        (function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const gameOverScreen = document.getElementById('game-over-screen');
            const currentScoreEl = document.getElementById('current-score');
            const highScoreEl = document.getElementById('high-score');
            const retryButton = document.getElementById('retry-button');
            const gameOverMessageEl = document.getElementById('game-over-message');

            // --- CONSTANTS ---
            const CANVAS_WIDTH = 360;
            const CANVAS_HEIGHT = 640;
            const PLAYER_WIDTH = 30;
            const PLAYER_HEIGHT = 30;
            const PLAYER_START_X = 50;
            const PLAYER_START_Y = CANVAS_HEIGHT / 2;
            const JUMP_STRENGTH = -450;
            const GRAVITY = 2200;
            const OBSTACLE_WIDTH = 40;
            const OBSTACLE_SPEED = -210;
            const OBSTACLE_SPACING = 260;
            const MIN_OBSTACLE_GAP = 120;
            const MAX_OBSTACLE_GAP = 140;

            // --- GAME STATE ---
            let gameState = 'Start'; // Start, Playing, GameOver
            let score = 0;
            let highScore = 0;
            try {
                highScore = localStorage.getItem('jumpAndRunHighScore') || 0;
            } catch (e) {
                console.warn("Could not access localStorage. High scores will not be loaded.");
            }
            let player, obstacles, scoreBuffer, lastObstacleYCenter, lastTime;

            // Set canvas resolution
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            function resetGame() {
                player = {
                    x: PLAYER_START_X,
                    y: PLAYER_START_Y,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT,
                    velocityY: 0,
                };
                obstacles = [];
                score = 0;
                scoreBuffer = 0;
                lastObstacleYCenter = CANVAS_HEIGHT / 2;
                gameOverScreen.style.display = 'none';
                gameState = 'Playing';
                lastTime = performance.now();
            }

            function handleInput(e) {
                e.preventDefault();
                // This function handles input on the canvas for starting the game and jumping
                if (gameState === 'Start') {
                    resetGame();
                } else if (gameState === 'Playing') {
                    player.velocityY = JUMP_STRENGTH;
                }
            }
            
            function getGameOverMessage(score) {
                let messages;
                if (score <= 3) {
                    messages = [
                        "Was that a practice run?",
                        "My grandma could beat that score.",
                        "Did you confuse the screen with a wall?",
                        "Gravity: 1, You: 0."
                    ];
                } else if (score <= 10) {
                    messages = [
                        "Okay, you're trying. Maybe.",
                        "You're getting better at this whole 'game over' thing.",
                        "That was... an attempt.",
                        "Slightly better than a rock."
                    ];
                } else if (score <= 25) {
                    messages = [
                        "Not bad. For you.",
                        "Hey, that was almost impressive.",
                        "You're starting to get the hang of it.",
                        "Respectable. I guess."
                    ];
                } else {
                    messages = [
                        "Are you a wizard?",
                        "That was legendary!",
                        "Okay, you can stop showing off now.",
                        "New high score! You've officially peaked."
                    ];
                }
                return messages[Math.floor(Math.random() * messages.length)];
            }
            
            function showGameOverScreen() {
                currentScoreEl.textContent = score;
                highScoreEl.textContent = highScore;
                gameOverMessageEl.textContent = getGameOverMessage(score);
                gameOverScreen.style.display = 'flex';
            }
            
            function update(deltaTime) {
                if (gameState !== 'Playing') return;

                // Player physics
                player.velocityY += GRAVITY * deltaTime;
                player.y += player.velocityY * deltaTime;

                // Obstacle management
                const lastObstacle = obstacles[obstacles.length - 1];
                if (!lastObstacle || lastObstacle.x < CANVAS_WIDTH - OBSTACLE_SPACING) {
                    const gap = Math.random() * (MAX_OBSTACLE_GAP - MIN_OBSTACLE_GAP) + MIN_OBSTACLE_GAP;
                    const verticalPadding = 50;
                    
                    const minCenterY = gap / 2 + verticalPadding;
                    const maxCenterY = CANVAS_HEIGHT - gap / 2 - verticalPadding;
                    const newCenterY = Math.max(minCenterY, Math.min(maxCenterY, lastObstacleYCenter + (Math.random() - 0.5) * 200));

                    const obstacleY = newCenterY - gap / 2;
                    lastObstacleYCenter = newCenterY;

                    obstacles.push({ x: CANVAS_WIDTH, y: 0, width: OBSTACLE_WIDTH, height: obstacleY, passed: false });
                    obstacles.push({ x: CANVAS_WIDTH, y: obstacleY + gap, width: OBSTACLE_WIDTH, height: CANVAS_HEIGHT - obstacleY - gap, passed: false });
                }

                // Move and update obstacles
                obstacles.forEach(obstacle => {
                    obstacle.x += OBSTACLE_SPEED * deltaTime;
                    if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                        obstacle.passed = true;
                        scoreBuffer += 0.5; // Each pair of obstacles gives 1 point
                    }
                });

                // Update score
                score = Math.floor(scoreBuffer);

                // Remove off-screen obstacles
                obstacles = obstacles.filter(o => o.x + o.width > 0);

                // Collision detection
                let isGameOver = false;
                if (player.y < 0 || player.y + player.height > CANVAS_HEIGHT) {
                    isGameOver = true;
                }
                for (const obstacle of obstacles) {
                    if (
                        player.x < obstacle.x + obstacle.width &&
                        player.x + player.width > obstacle.x &&
                        player.y < obstacle.y + obstacle.height &&
                        player.y + player.height > obstacle.y
                    ) {
                        isGameOver = true;
                        break;
                    }
                }
                
                if (isGameOver) {
                    if (score > highScore) {
                        highScore = score;
                        try {
                            localStorage.setItem('jumpAndRunHighScore', highScore);
                        } catch (e) {
                            console.warn("Could not access localStorage. High score was not saved.");
                        }
                    }
                    gameState = 'GameOver';
                    showGameOverScreen();

                    // Disable retry button for a moment to prevent accidental clicks
                    retryButton.disabled = true;
                    retryButton.classList.add('disabled');

                    setTimeout(() => {
                        retryButton.disabled = false;
                        retryButton.classList.remove('disabled');
                    }, 1000); // 1-second delay before retry is possible
                }
            }

            function draw(timestamp) {
                // Background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                if (gameState === 'Start') {
                    drawText("Jump", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 4 - 35, 60, '800');
                    drawText("& Run", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 4 + 35, 60, '800');
                    
                    // Animate player character bobbing up and down
                    const bobbingAmplitude = 10;
                    const bobbingFrequency = 0.002;
                    const playerCenterY = CANVAS_HEIGHT / 2 - 20; // Move it up a bit
                    const playerBobbingY = playerCenterY + bobbingAmplitude * Math.sin(timestamp * bobbingFrequency);

                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(CANVAS_WIDTH / 2 - PLAYER_WIDTH / 2, playerBobbingY, PLAYER_WIDTH, PLAYER_HEIGHT);
                    
                    drawText("Tap to Play", CANVAS_WIDTH / 2, CANVAS_HEIGHT * 0.75, 24);
                    return;
                }

                // Draw obstacles
                ctx.fillStyle = '#CCCCCC';
                obstacles.forEach(obstacle => {
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });

                // Draw player
                ctx.fillStyle = '#FFFFFF';
                if (player) { // Ensure player exists before drawing
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }
                
                // Draw Score during play
                if (gameState === 'Playing') {
                    ctx.globalAlpha = 0.4;
                    drawText(score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 4, 100, '800');
                    ctx.globalAlpha = 1.0;
                }
            }
            
            function drawText(text, x, y, size, weight = '600') {
                 ctx.fillStyle = '#EEEEEE';
                 ctx.font = `${weight} ${size}px Poppins`;
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText(text, x, y);
            }

            function gameLoop(timestamp) {
                if (!lastTime) {
                    lastTime = timestamp;
                }
                const deltaTime = Math.min((timestamp - lastTime) / 1000, 0.1); // Clamp delta time
                lastTime = timestamp;
                
                update(deltaTime);
                draw(timestamp); // Pass timestamp for animations
                
                requestAnimationFrame(gameLoop);
            }

            // --- EVENT LISTENERS ---
            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', handleInput, { passive: false });
            
            retryButton.addEventListener('click', () => {
                if (gameState === 'GameOver' && !retryButton.disabled) {
                    resetGame();
                }
            });

            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (gameState === 'Start') {
                        resetGame();
                    } else if (gameState === 'GameOver' && !retryButton.disabled) {
                        resetGame();
                    } else if (gameState === 'Playing') {
                        player.velocityY = JUMP_STRENGTH;
                    }
                }
            });

            // --- START GAME ---
            requestAnimationFrame(gameLoop);
        })();
    </script>
</body>
</html>