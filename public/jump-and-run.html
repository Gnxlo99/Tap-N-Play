<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Jump & Run</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;800&display=swap" rel="stylesheet">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-T815YBZXVX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-T815YBZXVX');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8046202594767916"
     crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222831;
            font-family: 'Poppins', sans-serif;
            color: #EEEEEE;
            overflow: hidden;
            overscroll-behavior-y: contain;
            -webkit-tap-highlight-color: transparent;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 360px; /* Corresponds to CANVAS_WIDTH */
            aspect-ratio: 9 / 16;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 10;
            color: #EEEEEE;
        }
        .modal-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
            align-items: center;
            padding: 20px 0;
            box-sizing: border-box;
        }
        .modal-content h1 {
            font-size: 48px;
            font-weight: 800;
            margin: 0;
        }
        #scores-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            width: 100%;
        }
        .score-box {
            background-color: #313842;
            padding: 10px 20px;
            border-radius: 12px;
            text-align: center;
            min-width: 120px;
            border: 1px solid #444;
        }
        .score-box p {
            margin: 0 0 5px 0;
            font-size: 16px;
            font-weight: 600;
            color: #AAAAAA;
        }
        .score-box span {
            font-size: 32px;
            font-weight: 800;
            color: #EEEEEE;
            display: block;
        }
        #game-over-message-container {
             min-height: 50px; 
             display: flex;
             flex-direction: column;
             align-items: center;
             justify-content: center;
        }
        #game-over-message {
            font-size: 22px;
            font-style: italic;
            color: #AAAAAA;
            margin: 0 20px;
        }
        #ad-container {
            width: 320px;
            height: 50px;
            border-radius: 8px;
            overflow: hidden;
            background-color: #313842;
        }
        #ad-banner-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        #button-container {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .action-button {
            font-family: 'Poppins', sans-serif;
            font-size: 20px;
            font-weight: 600;
            border: none;
            padding: 12px 30px;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s ease, opacity 0.3s ease, background-color 0.2s ease;
        }
        #retry-button {
             color: #222831;
             background-color: #EEEEEE;
        }
        #share-button {
            color: #EEEEEE;
            background-color: #4769FF;
        }
        .action-button:active {
            transform: scale(0.95);
        }
        #retry-button.disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        #customize-button {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Poppins', sans-serif;
            font-size: 16px;
            font-weight: 600;
            color: #EEEEEE;
            background-color: rgba(238, 238, 238, 0.2);
            border: 2px solid #EEEEEE;
            padding: 8px 20px;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s ease, background-color 0.2s ease;
            z-index: 5;
        }
        #customize-button:active {
            transform: translateX(-50%) scale(0.95);
        }
        #confetti-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 11;
            overflow: hidden;
        }
        .confetti-piece {
            position: absolute;
            width: 8px;
            height: 16px;
            will-change: transform;
        }

        /* --- Customization Modal --- */
        #customize-screen {
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 20;
        }
        #customize-modal {
            background-color: #313842;
            padding: 20px;
            border-radius: 15px;
            width: 90%;
            max-width: 320px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
        }
        #customize-modal h2 {
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        }
        #customize-tabs {
            display: flex;
            margin-bottom: 15px;
            background-color: #222831;
            border-radius: 50px;
            padding: 5px;
        }
        .tab-button {
            flex: 1;
            padding: 8px;
            border: none;
            background-color: transparent;
            color: #AAAAAA;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 14px;
            border-radius: 50px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .tab-button.active {
            background-color: #4769FF;
            color: #EEEEEE;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        #appearance-grid, #env-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .appearance-item {
            aspect-ratio: 1 / 1;
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s ease, border-color 0.2s ease;
            overflow: hidden;
        }
        .appearance-item:active {
            transform: scale(0.9);
        }
        .appearance-item.selected {
            border-color: #54D77B;
            box-shadow: 0 0 10px #54D77B;
        }
        .appearance-item.locked {
            filter: grayscale(1);
            opacity: 0.6;
            cursor: not-allowed;
        }
        .appearance-item.locked .lock-icon {
            display: block;
        }
        .lock-icon {
            display: none;
            font-size: 24px;
        }
        #unlock-hint, #env-unlock-hint {
            text-align: center;
            font-size: 14px;
            color: #AAAAAA;
            min-height: 20px;
            margin-bottom: 20px;
        }
        #close-customize-button {
            width: 100%;
            background-color: #4769FF;
            color: #EEEEEE;
            margin-top: auto;
        }
        
        /* --- Unlock Toast Notification --- */
        #unlock-toast {
            position: absolute;
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #54D77B;
            color: #222831;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 14px;
            z-index: 30;
            transition: top 0.5s ease-in-out;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            text-align: center;
        }
        #unlock-toast.show {
            top: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="confetti-container"></div>
        <div id="unlock-toast">New Item Unlocked! âœ¨</div>
        <div id="game-over-screen" class="screen-overlay" style="display: none;">
            <div class="modal-content">
                <h1>Game Over</h1>
                <div id="scores-container">
                    <div class="score-box">
                        <p>Score</p>
                        <span id="current-score">0</span>
                    </div>
                    <div class="score-box">
                        <p>High Score</p>
                        <span id="high-score">0</span>
                    </div>
                </div>
                <div id="game-over-message-container">
                    <p id="game-over-message"></p>
                </div>
                <div id="ad-container">
                    <iframe id="ad-banner-iframe" src="about:blank" scrolling="no"></iframe>
                </div>
                <div id="button-container">
                    <button id="share-button" class="action-button">Share</button>
                    <button id="retry-button" class="action-button">Retry</button>
                </div>
            </div>
        </div>
        <div id="customize-screen" class="screen-overlay" style="display: none;">
             <div id="customize-modal">
                <h2>Customize</h2>
                <div id="customize-tabs">
                    <button class="tab-button active" data-tab="player">Player</button>
                    <button class="tab-button" data-tab="environment">Environment</button>
                </div>
                <div class="tab-content active" id="player-tab-content">
                    <div id="appearance-grid"></div>
                    <p id="unlock-hint"></p>
                </div>
                <div class="tab-content" id="environment-tab-content">
                    <div id="env-grid"></div>
                    <p id="env-unlock-hint"></p>
                </div>
                <button id="close-customize-button" class="action-button">Close</button>
            </div>
        </div>
        <button id="customize-button">Customize</button>
    </div>

    <script>
        (function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const gameOverScreen = document.getElementById('game-over-screen');
            const currentScoreEl = document.getElementById('current-score');
            const highScoreEl = document.getElementById('high-score');
            const retryButton = document.getElementById('retry-button');
            const shareButton = document.getElementById('share-button');
            const gameOverMessageEl = document.getElementById('game-over-message');
            const adBannerIframe = document.getElementById('ad-banner-iframe');
            const customizeButton = document.getElementById('customize-button');
            const confettiContainer = document.getElementById('confetti-container');
            const customizeScreen = document.getElementById('customize-screen');
            const appearanceGrid = document.getElementById('appearance-grid');
            const unlockHint = document.getElementById('unlock-hint');
            const closeCustomizeButton = document.getElementById('close-customize-button');
            const unlockToast = document.getElementById('unlock-toast');
            const customizeTabs = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            const envGrid = document.getElementById('env-grid');
            const envUnlockHint = document.getElementById('env-unlock-hint');


            // --- CONSTANTS ---
            const CANVAS_WIDTH = 360;
            const CANVAS_HEIGHT = 640;
            const PLAYER_WIDTH = 30;
            const PLAYER_HEIGHT = 30;
            const PLAYER_START_X = 50;
            const PLAYER_START_Y = CANVAS_HEIGHT / 2;
            const JUMP_STRENGTH = -550;
            const GRAVITY = 1800;
            const OBSTACLE_WIDTH = 50;
            let OBSTACLE_SPEED = -200;
            const OBSTACLE_SPACING = 280;
            const OBSTACLE_GAP_MIN = 140;
            const OBSTACLE_GAP_MAX = 180;
            
            const APPEARANCES = [
                { shape: 'square', color: '#FFFFFF', unlock: { type: 'default' }, description: 'Default square' },
                { shape: 'circle', color: '#FFFFFF', unlock: { type: 'score', value: 5 }, description: 'Score 5 points' },
                { shape: 'triangle', color: '#FFFFFF', unlock: { type: 'score', value: 10 }, description: 'Score 10 points' },
                { shape: 'hexagon', color: '#CCCCCC', unlock: { type: 'score', value: 20 }, description: 'Score 20 points' },
                { shape: 'star', color: '#FFD700', unlock: { type: 'score', value: 30 }, description: 'Score 30 points', jumpEffect: { colors: ['#FFD700', '#FFA500'], count: 8, life: 0.5 } },
                { shape: 'crystal', color: '#ADD8E6', unlock: { type: 'score', value: 50 }, description: 'Score 50 points', jumpEffect: { colors: ['#ADD8E6', '#FFFFFF'], count: 10, life: 0.6 } },
                { shape: 'diamond', color: '#00FFFF', unlock: { type: 'score', value: 75 }, description: 'Score 75 points', jumpEffect: { colors: ['#00FFFF', '#00BFFF'], count: 12, life: 0.7 } },
                { shape: 'rotating_color_square', color: '#FF5733', unlock: { type: 'score', value: 100 }, description: 'Score 100 points', jumpEffect: { colors: ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#F4FF33', '#33FFF1'], count: 15, life: 1.0 } }
            ];
             const ENVIRONMENTS = [
                { name: 'Day', colors: { bg: '#87CEEB', obstacle: '#4CAF50', ground: '#6B4F35' }, unlock: { type: 'default' }, description: 'Classic day theme' },
                { name: 'Night', colors: { bg: '#2C3E50', obstacle: '#95A5A6', ground: '#59636D' }, unlock: { type: 'score', value: 15 }, description: 'Score 15 points' },
                { name: 'Sunset', colors: { bg: 'linear-gradient(#FF7E5F, #FEB47B)', obstacle: '#4A0E4E', ground: '#3D0B3E' }, unlock: { type: 'score', value: 40 }, description: 'Score 40 points' },
                { name: 'Space', colors: { bg: '#000020', obstacle: '#9A7CFC', ground: '#43346C' }, unlock: { type: 'score', value: 80 }, description: 'Score 80 points' }
            ];

            // --- GAME STATE ---
            let player, obstacles, score, highScore, gameState, lastTime, obstacleTimer;
            let currentAppearance, unlockedAppearances, currentEnvironment, unlockedEnvironments;
            let particles = [];
            let gamesPlayedSinceAd = 0;

            // --- SETUP & INITIALIZATION ---
            function init() {
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
                loadProgress();
                setupEventListeners();
                resetGame();
                gameState = 'start';
                drawStartScreen();
            }

            function loadProgress() {
                highScore = parseInt(localStorage.getItem('jr_highScore')) || 0;
                unlockedAppearances = JSON.parse(localStorage.getItem('jr_unlockedAppearances')) || [APPEARANCES[0].shape];
                currentAppearance = localStorage.getItem('jr_currentAppearance') || APPEARANCES[0].shape;
                unlockedEnvironments = JSON.parse(localStorage.getItem('jr_unlockedEnvironments')) || [ENVIRONMENTS[0].name];
                currentEnvironment = localStorage.getItem('jr_currentEnvironment') || ENVIRONMENTS[0].name;
                highScoreEl.textContent = highScore;
            }

            function saveProgress() {
                localStorage.setItem('jr_highScore', highScore);
                localStorage.setItem('jr_unlockedAppearances', JSON.stringify(unlockedAppearances));
                localStorage.setItem('jr_currentAppearance', currentAppearance);
                localStorage.setItem('jr_unlockedEnvironments', JSON.stringify(unlockedEnvironments));
                localStorage.setItem('jr_currentEnvironment', currentEnvironment);
            }

            // --- GAME LOOP ---
            function gameLoop(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                if (gameState === 'playing') {
                    update(deltaTime);
                    draw();
                }
                
                requestAnimationFrame(gameLoop);
            }

            function update(deltaTime) {
                // Update player
                player.update(deltaTime);

                // Update obstacles
                obstacleTimer += deltaTime;
                if (obstacleTimer > OBSTACLE_SPACING / Math.abs(OBSTACLE_SPEED)) {
                    addObstacle();
                    obstacleTimer = 0;
                }

                let scored = false;
                obstacles.forEach(obstacle => {
                    obstacle.x += OBSTACLE_SPEED * deltaTime;
                    if (obstacle.x + OBSTACLE_WIDTH < player.x && !obstacle.scored) {
                        score++;
                        obstacle.scored = true;
                        scored = true;
                    }
                });
                
                if(scored) {
                    OBSTACLE_SPEED -= 2; // Increase speed slightly with each score
                }

                // Remove off-screen obstacles
                obstacles = obstacles.filter(obstacle => obstacle.x + OBSTACLE_WIDTH > 0);
                
                // Update particles
                particles.forEach((p, index) => {
                    p.update(deltaTime);
                    if (p.life <= 0) particles.splice(index, 1);
                });

                // Check collisions
                checkCollisions();
            }

            function draw() {
                const env = ENVIRONMENTS.find(e => e.name === currentEnvironment).colors;
                
                // Draw background
                if (typeof env.bg === 'string' && env.bg.startsWith('linear-gradient')) {
                    const colors = env.bg.match(/#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g);
                    const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                    gradient.addColorStop(0, colors[0]);
                    gradient.addColorStop(1, colors[1]);
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = env.bg;
                }
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw ground
                ctx.fillStyle = env.ground;
                ctx.fillRect(0, CANVAS_HEIGHT - 20, CANVAS_WIDTH, 20);

                // Draw obstacles
                ctx.fillStyle = env.obstacle;
                obstacles.forEach(obstacle => {
                    ctx.fillRect(obstacle.x, 0, OBSTACLE_WIDTH, obstacle.topHeight);
                    ctx.fillRect(obstacle.x, CANVAS_HEIGHT - obstacle.bottomHeight, OBSTACLE_WIDTH, obstacle.bottomHeight);
                });

                // Draw player
                player.draw(ctx);
                
                // Draw particles
                 particles.forEach(p => p.draw(ctx));

                // Draw score
                ctx.fillStyle = 'white';
                ctx.font = '60px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText(score, CANVAS_WIDTH / 2, 80);
            }
            
            function drawStartScreen() {
                 const env = ENVIRONMENTS.find(e => e.name === currentEnvironment).colors;
                 if (typeof env.bg === 'string' && env.bg.startsWith('linear-gradient')) {
                    const colors = env.bg.match(/#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g);
                    const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                    gradient.addColorStop(0, colors[0]);
                    gradient.addColorStop(1, colors[1]);
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = env.bg;
                }
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = env.ground;
                ctx.fillRect(0, CANVAS_HEIGHT - 20, CANVAS_WIDTH, 20);

                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = '48px Poppins';
                ctx.fillText('Jump & Run', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 50);
                ctx.font = '24px Poppins';
                ctx.fillText('Tap to Start', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            }

            // --- GAME STATE MANAGEMENT ---
            function startGame() {
                if (gameState !== 'playing') {
                    resetGame();
                    gameState = 'playing';
                    gameOverScreen.style.display = 'none';
                    customizeButton.style.display = 'none';
                    lastTime = null;
                    requestAnimationFrame(gameLoop);
                }
            }

            function resetGame() {
                player = createPlayer();
                obstacles = [];
                score = 0;
                obstacleTimer = 0;
                particles = [];
                OBSTACLE_SPEED = -200;
                addObstacle(); 
            }

            function setGameOver() {
                gameState = 'gameOver';
                if (score > highScore) {
                    highScore = score;
                    gameOverMessageEl.textContent = 'New High Score!';
                    createConfetti();
                } else {
                     const messages = ["Great try!", "Almost there!", "Keep trying!", "You can do it!"];
                     gameOverMessageEl.textContent = messages[Math.floor(Math.random() * messages.length)];
                }
                
                saveProgress();
                checkUnlocks();

                currentScoreEl.textContent = score;
                highScoreEl.textContent = highScore;
                gameOverScreen.style.display = 'flex';
                customizeButton.style.display = 'block';

                gamesPlayedSinceAd++;
                if (gamesPlayedSinceAd >= 1) {
                    showAd();
                    gamesPlayedSinceAd = 0;
                }
            }
            
            function showAd() {
                adBannerIframe.src = 'banner.html';
            }

            // --- ENTITIES & MECHANICS ---
            function createPlayer() {
                return {
                    x: PLAYER_START_X, y: PLAYER_START_Y, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, vy: 0, rotation: 0,
                    jump() {
                        this.vy = JUMP_STRENGTH;
                        const appearance = APPEARANCES.find(a => a.shape === currentAppearance);
                        if (appearance && appearance.jumpEffect) {
                           createParticles(this.x + this.width / 2, this.y + this.height / 2, appearance.jumpEffect.colors, appearance.jumpEffect.count, appearance.jumpEffect.life);
                        }
                    },
                    update(deltaTime) {
                        this.vy += GRAVITY * deltaTime;
                        this.y += this.vy * deltaTime;

                        if (this.y + this.height > CANVAS_HEIGHT - 20) { // Ground collision
                            this.y = CANVAS_HEIGHT - 20 - this.height;
                            this.vy = 0;
                            setGameOver();
                        }
                        if (this.y < 0) { // Ceiling collision
                            this.y = 0;
                            this.vy = 0;
                        }
                    },
                    draw(ctx) {
                        const appearance = APPEARANCES.find(a => a.shape === currentAppearance);
                        let color = appearance ? appearance.color : '#FFFFFF';
                        
                        // Handle dynamic color for special shapes
                        if (appearance.shape === 'rotating_color_square') {
                            const colors = appearance.jumpEffect.colors;
                            color = colors[Math.floor(Date.now() / 200) % colors.length];
                        }
                        ctx.fillStyle = color;
                        
                        ctx.save();
                        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                        switch (appearance.shape) {
                            case 'circle':
                                ctx.beginPath(); ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2); ctx.fill();
                                break;
                            case 'triangle':
                                ctx.beginPath(); ctx.moveTo(0, -this.height / 2); ctx.lineTo(-this.width / 2, this.height / 2); ctx.lineTo(this.width / 2, this.height / 2); ctx.closePath(); ctx.fill();
                                break;
                             case 'hexagon':
                                ctx.beginPath();
                                for (let i = 0; i < 6; i++) {
                                    ctx.lineTo(this.width/2 * Math.cos(i * 2 * Math.PI / 6), this.height/2 * Math.sin(i * 2 * Math.PI / 6));
                                }
                                ctx.closePath(); ctx.fill();
                                break;
                            case 'star':
                                drawStar(ctx, 0, 0, 5, this.width / 2, this.width / 4);
                                ctx.fill();
                                break;
                            case 'crystal': case 'diamond':
                                drawDiamond(ctx, 0, 0, this.width, this.height);
                                ctx.fill();
                                break;
                            case 'square': case 'rotating_color_square': default:
                                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                                break;
                        }
                        ctx.restore();
                    }
                };
            }

            function addObstacle() {
                const gap = Math.random() * (OBSTACLE_GAP_MAX - OBSTACLE_GAP_MIN) + OBSTACLE_GAP_MIN;
                const topHeight = Math.random() * (CANVAS_HEIGHT - gap - 40) + 20; // 20px buffer top/bottom
                obstacles.push({
                    x: CANVAS_WIDTH,
                    topHeight: topHeight,
                    bottomHeight: CANVAS_HEIGHT - topHeight - gap,
                    scored: false
                });
            }

            function checkCollisions() {
                for (const obstacle of obstacles) {
                    if (player.x < obstacle.x + OBSTACLE_WIDTH &&
                        player.x + player.width > obstacle.x &&
                        (player.y < obstacle.topHeight || player.y + player.height > CANVAS_HEIGHT - obstacle.bottomHeight)) {
                        setGameOver();
                        return;
                    }
                }
            }

            // --- EVENT LISTENERS ---
            function setupEventListeners() {
                window.addEventListener('click', handleInput);
                window.addEventListener('touchstart', handleInput, { passive: false });
                retryButton.addEventListener('click', () => {
                     adBannerIframe.src = 'about:blank';
                     startGame();
                });
                customizeButton.addEventListener('click', showCustomizeScreen);
                closeCustomizeButton.addEventListener('click', hideCustomizeScreen);
                
                 customizeTabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        customizeTabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        tabContents.forEach(content => content.classList.remove('active'));
                        document.getElementById(`${tab.dataset.tab}-tab-content`).classList.add('active');
                    });
                });

                shareButton.addEventListener('click', () => {
                    if (navigator.share) {
                        navigator.share({
                            title: 'Jump & Run',
                            text: `I scored ${score} in Jump & Run! Can you beat me?`,
                            url: window.location.href
                        }).catch(console.error);
                    } else {
                        alert('Share not supported on this browser.');
                    }
                });
            }

            function handleInput(e) {
                e.preventDefault();
                if (gameState === 'playing') {
                    player.jump();
                } else if (gameState === 'start' || gameState === 'gameOver') {
                     // Check if click is inside customize modal
                    if (customizeScreen.style.display !== 'flex' || !e.target.closest('#customize-modal')) {
                        adBannerIframe.src = 'about:blank';
                        hideCustomizeScreen();
                        startGame();
                    }
                }
            }

            // --- CUSTOMIZATION & UNLOCKS ---
            function showCustomizeScreen() {
                populateAppearanceGrid();
                populateEnvGrid();
                customizeScreen.style.display = 'flex';
            }
            function hideCustomizeScreen() {
                customizeScreen.style.display = 'none';
            }

            function populateAppearanceGrid() {
                appearanceGrid.innerHTML = '';
                APPEARANCES.forEach(app => {
                    const isUnlocked = unlockedAppearances.includes(app.shape);
                    const item = document.createElement('div');
                    item.className = 'appearance-item';
                    item.classList.toggle('locked', !isUnlocked);
                    item.classList.toggle('selected', currentAppearance === app.shape);
                    
                    const canvasEl = document.createElement('canvas');
                    canvasEl.width = 60;
                    canvasEl.height = 60;
                    const itemCtx = canvasEl.getContext('2d');
                    
                    const mockPlayer = {
                        x: 30, y: 30, width: 30, height: 30,
                        draw: createPlayer().draw, // Use the real draw function
                    };
                    
                    // Temporarily set currentAppearance for drawing the preview
                    const tempAppearance = currentAppearance;
                    currentAppearance = app.shape;
                    mockPlayer.draw(itemCtx);
                    currentAppearance = tempAppearance;

                    item.appendChild(canvasEl);

                    if (!isUnlocked) {
                        const lock = document.createElement('span');
                        lock.className = 'lock-icon';
                        lock.textContent = 'ðŸ”’';
                        item.appendChild(lock);
                    }
                    
                    item.addEventListener('click', () => {
                        if (isUnlocked) {
                            currentAppearance = app.shape;
                            saveProgress();
                            populateAppearanceGrid(); // Repopulate to show selection
                            unlockHint.textContent = app.description;
                        } else {
                             unlockHint.textContent = `Unlock by: ${app.description}`;
                        }
                    });
                    appearanceGrid.appendChild(item);
                });
            }
            
            function populateEnvGrid() {
                envGrid.innerHTML = '';
                ENVIRONMENTS.forEach(env => {
                     const isUnlocked = unlockedEnvironments.includes(env.name);
                     const item = document.createElement('div');
                     item.className = 'appearance-item'; // Re-use styling
                     item.classList.toggle('locked', !isUnlocked);
                     item.classList.toggle('selected', currentEnvironment === env.name);
                     
                     // Create a preview of the environment background
                     if (typeof env.colors.bg === 'string' && env.colors.bg.startsWith('linear-gradient')) {
                         item.style.background = env.colors.bg;
                     } else {
                         item.style.backgroundColor = env.colors.bg;
                     }

                     if (!isUnlocked) {
                        const lock = document.createElement('span');
                        lock.className = 'lock-icon';
                        lock.textContent = 'ðŸ”’';
                        item.appendChild(lock);
                    }
                     
                     item.addEventListener('click', () => {
                        if (isUnlocked) {
                            currentEnvironment = env.name;
                            saveProgress();
                            populateEnvGrid(); // Repopulate to show selection
                             envUnlockHint.textContent = env.description;
                             // Redraw start screen if game hasn't started
                             if(gameState === 'start') drawStartScreen();
                        } else {
                             envUnlockHint.textContent = `Unlock by: ${env.description}`;
                        }
                    });
                    envGrid.appendChild(item);
                });
            }

            function checkUnlocks() {
                let newUnlock = false;
                APPEARANCES.forEach(app => {
                    if (!unlockedAppearances.includes(app.shape) && app.unlock.type === 'score' && highScore >= app.unlock.value) {
                        unlockedAppearances.push(app.shape);
                        newUnlock = true;
                    }
                });
                ENVIRONMENTS.forEach(env => {
                     if (!unlockedEnvironments.includes(env.name) && env.unlock.type === 'score' && highScore >= env.unlock.value) {
                        unlockedEnvironments.push(env.name);
                        newUnlock = true;
                    }
                });

                if (newUnlock) {
                    saveProgress();
                    showUnlockToast();
                }
            }
            
            function showUnlockToast() {
                unlockToast.classList.add('show');
                setTimeout(() => {
                    unlockToast.classList.remove('show');
                }, 3000);
            }

            // --- VISUAL EFFECTS ---
            function createParticles(x, y, colors, count, life) {
                 for (let i = 0; i < count; i++) {
                    particles.push(new Particle(x, y, colors, life));
                }
            }
             class Particle {
                constructor(x, y, colors, life) {
                    this.x = x; this.y = y; this.life = life + Math.random() * 0.2;
                    this.color = colors[Math.floor(Math.random() * colors.length)];
                    this.size = Math.random() * 5 + 2;
                    this.vx = (Math.random() - 0.5) * 150;
                    this.vy = (Math.random() - 0.5) * 150;
                    this.gravity = 300;
                }
                update(deltaTime) {
                    this.vy += this.gravity * deltaTime;
                    this.x += this.vx * deltaTime;
                    this.y += this.vy * deltaTime;
                    this.life -= deltaTime;
                }
                draw(ctx) {
                    ctx.globalAlpha = Math.max(0, this.life);
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.globalAlpha = 1.0;
                }
            }

            function createConfetti() {
                confettiContainer.innerHTML = '';
                const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
                for (let i = 0; i < 100; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti-piece';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = `${Math.random() * 100}%`;
                    const animDuration = Math.random() * 3 + 2;
                    confetti.style.animation = `fall ${animDuration}s linear forwards`;
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    confettiContainer.appendChild(confetti);
                }
                // Add keyframes for animation dynamically
                const styleSheet = document.styleSheets[0];
                const keyframes = `@keyframes fall {
                    to {
                        transform: translateY(${CANVAS_HEIGHT + 20}px) rotate(${Math.random() * 360 + 360}deg);
                        opacity: 0;
                    }
                }`;
                 try {
                     styleSheet.insertRule(keyframes, styleSheet.cssRules.length);
                 } catch (e) { console.error(e) }
            }

            // --- HELPER DRAWING FUNCTIONS ---
            function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                let step = Math.PI / spikes;
                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
            }
             function drawDiamond(ctx, x, y, width, height) {
                ctx.beginPath();
                ctx.moveTo(x, y - height / 2); // Top
                ctx.lineTo(x + width / 2, y); // Right
                ctx.lineTo(x, y + height / 2); // Bottom
                ctx.lineTo(x - width / 2, y); // Left
                ctx.closePath();
            }

            // --- START ---
            init();
        })();
    </script>
</body>
</html>
