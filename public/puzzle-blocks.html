<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Puzzle Blocks</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;800&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #1a1a2e; font-family: 'Poppins', sans-serif; overflow: hidden; }
        #game-wrapper { display: flex; align-items: flex-start; gap: 20px; }
        canvas { display: block; background-color: #0f0f23; border: 4px solid #e0e0e0; border-radius: 8px; }
        #game-info { color: white; width: 160px; }
        #game-info h2 { margin-top: 0; font-size: 24px; text-transform: uppercase; }
        #game-info p { font-size: 18px; margin: 10px 0; background: #0f0f23; padding: 10px; border-radius: 5px; }
        #game-over-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.8); color: white; text-align: center; }
        .hidden { display: none; }
        h1 { font-size: 48px; }
        button { font-family: 'Poppins', sans-serif; font-size: 24px; padding: 15px 40px; border-radius: 50px; border: none; background: #fff; color: #000; cursor: pointer; }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="game-info">
            <h2>Score</h2>
            <p id="score">0</p>
            <h2>Lines</h2>
            <p id="lines">0</p>
            <h2>Level</h2>
            <p id="level">1</p>
        </div>
    </div>
    <div id="game-over-screen" class="hidden">
        <h1>Game Over</h1>
        <button id="retry-button">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const linesEl = document.getElementById('lines');
        const levelEl = document.getElementById('level');
        const gameOverScreen = document.getElementById('game-over-screen');
        const retryButton = document.getElementById('retry-button');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        ctx.canvas.width = COLS * BLOCK_SIZE;
        ctx.canvas.height = ROWS * BLOCK_SIZE;

        const COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
        const PIECES = [
            [[1,1,1,1]], // I
            [[2,2],[2,2]], // O
            [[0,3,0],[3,3,3]], // T
            [[4,0,0],[4,4,4]], // L
            [[0,0,5],[5,5,5]], // J
            [[0,6,6],[6,6,0]], // S
            [[7,7,0],[0,7,7]]  // Z
        ];

        let board, piece, score, lines, level, dropStart, gameOver;

        function init() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            lines = 0;
            level = 1;
            gameOver = false;
            updateUI();
            newPiece();
            dropStart = Date.now();
            gameOverScreen.classList.add('hidden');
            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            scoreEl.textContent = score;
            linesEl.textContent = lines;
            levelEl.textContent = level;
        }

        function newPiece() {
            const typeId = Math.floor(Math.random() * PIECES.length);
            const matrix = PIECES[typeId];
            piece = { matrix, x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2), y: 0 };
            if (collides()) {
                gameOver = true;
                gameOverScreen.classList.remove('hidden');
            }
        }

        function collides() {
            for (let y = 0; y < piece.matrix.length; y++) {
                for (let x = 0; x < piece.matrix[y].length; x++) {
                    if (piece.matrix[y][x] && (board[y + piece.y] && board[y + piece.y][x + piece.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function merge() {
            piece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        board[y + piece.y][x + piece.x] = value;
                    }
                });
            });
        }
        
        function rotate() {
            const matrix = piece.matrix;
            const N = matrix.length;
            const newMatrix = matrix.map((_, i) => matrix.map(col => col[i]).reverse());
            piece.matrix = newMatrix;
            if (collides()) {
                 piece.matrix = matrix; // revert
            }
        }
        
        function playerDrop() {
            piece.y++;
            if (collides()) {
                piece.y--;
                merge();
                sweep();
                newPiece();
            }
            dropStart = Date.now();
        }

        function sweep() {
            let rowCount = 0;
            outer: for (let y = ROWS - 1; y > 0; --y) {
                for (let x = 0; x < COLS; ++x) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                ++y;
                rowCount++;
            }
            if (rowCount > 0) {
                lines += rowCount;
                score += rowCount * 10 * level; // Simple scoring
                level = Math.floor(lines / 10) + 1;
                updateUI();
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });

            piece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect((x + piece.x) * BLOCK_SIZE, (y + piece.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }
        
        function gameLoop() {
            if (gameOver) return;
            let now = Date.now();
            let delta = now - dropStart;
            let dropInterval = 1000 / level;
            if (delta > dropInterval) {
                playerDrop();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', e => {
            if (gameOver) return;
            if (e.code === 'ArrowLeft') {
                piece.x--;
                if (collides()) piece.x++;
            } else if (e.code === 'ArrowRight') {
                piece.x++;
                if (collides()) piece.x--;
            } else if (e.code === 'ArrowDown') {
                playerDrop();
            } else if (e.code === 'ArrowUp') {
                rotate();
            }
        });
        
        retryButton.addEventListener('click', init);
        init();
    </script>
</body>
</html>
